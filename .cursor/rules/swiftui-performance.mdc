---
description: Critical SwiftUI performance and rendering rules to prevent grey screens and UI delays
globs: **/*.swift
alwaysApply: true
---

# SwiftUI Performance & Rendering Rules

## ❌ NEVER: Sheet Presentation for Complex Views

**Problem:** `.sheet()` presentation causes grey screen on first open due to SwiftUI cold-start rendering issues.

```swift
// ❌ DON'T: Sheet presentation for complex views
.sheet(isPresented: $showDetail) {
    DeviceDetailView(device: device)  // Grey screen on first open!
}

// ✅ DO: Use NavigationLink with NavigationStack
NavigationStack {
    NavigationLink(value: device) {
        DeviceCard(device: device)
    }
    .buttonStyle(.plain)
}
.navigationDestination(for: WLEDDevice.self) { device in
    DeviceDetailView(device: device)  // Renders instantly!
}
```

**Why:** NavigationStack pre-warms the view hierarchy, while sheets render on-demand causing visible delays.

---

## ❌ NEVER: Liquid Glass in Content Layer (Apple HIG Violation)

**Problem:** `.ultraThinMaterial`, multiple overlays, gradients, shadows, `compositingGroup()`, and `blendMode()` are GPU killers that cause 500ms+ rendering delays.

**Apple Guidelines:** "Don't use Liquid Glass in the content layer. Use Liquid Glass effects sparingly."

```swift
// ❌ DON'T: GPU-intensive liquid glass effects
RoundedRectangle(cornerRadius: 16)
    .fill(.ultraThinMaterial)  // GPU killer!
    .overlay {
        RadialGradient(...)  // More GPU overhead
    }
    .compositingGroup()  // Forces GPU compositing
    .blendMode(.overlay)  // More GPU work
    .shadow(color: .black.opacity(0.3), radius: 20)  // Multiple shadows = GPU death
    .shadow(color: .blue.opacity(0.2), radius: 15)
    .shadow(color: .blue.opacity(0.1), radius: 10)

// ✅ DO: Simple fills, single stroke, minimal shadow
RoundedRectangle(cornerRadius: 16)
    .fill(Color.white.opacity(0.12))
    .overlay(
        RoundedRectangle(cornerRadius: 16)
            .stroke(Color.white.opacity(0.2), lineWidth: 1)
    )
    .shadow(color: .black.opacity(0.15), radius: 8, x: 0, y: 4)  // Single shadow only
```

**Why:** Each material/blend/shadow layer forces GPU compositing passes. 3+ shadows = 500ms+ render time.

---

## ❌ NEVER: Button Wrappers Around NavigationLink Content

**Problem:** Button wrappers intercept all taps and prevent NavigationLink from working.

```swift
// ❌ DON'T: Button wrapper blocks NavigationLink
NavigationLink(value: device) {
    Button(action: { /* This intercepts ALL taps */ }) {
        DeviceCard(device: device)
    }
}

// ✅ DO: Interactive controls use .buttonStyle(.plain)
NavigationLink(value: device) {
    VStack {
        // Interactive control with .buttonStyle(.plain)
        Button(action: { togglePower() }) {
            Image(systemName: "power")
        }
        .buttonStyle(.plain)  // Allows NavigationLink to work for empty space
        
        // Card content...
    }
}
.buttonStyle(.plain)  // On NavigationLink itself
```

**Why:** Buttons capture all tap events unless explicitly styled with `.plain`.

---

## ⚠️ AVOID: Main Queue Flooding During View Rendering

**Problem:** `DispatchQueue.main.async` calls in computed properties or `init()` flood the main queue during rendering.

```swift
// ❌ DON'T: Async dispatches during rendering
struct MyView: View {
    @State private var gradient: Gradient?
    
    private var currentGradient: Gradient {
        guard let grad = gradient else {
            DispatchQueue.main.async {  // Floods main queue!
                self.gradient = defaultGradient
            }
            return defaultGradient
        }
        return grad
    }
}

// ✅ DO: Initialize state synchronously in init()
struct MyView: View {
    @State private var gradient: Gradient
    
    init() {
        _gradient = State(initialValue: defaultGradient)  // Synchronous!
    }
}
```

**Why:** Every view re-render schedules async work, flooding the main queue and blocking UI events.

---

## ✅ PERFORMANCE CHECKLIST for View Rendering

Before shipping any view:

- [ ] Uses `NavigationLink` instead of `.sheet()` for navigation
- [ ] NO `.ultraThinMaterial` or materials in content layer
- [ ] NO `compositingGroup()` or `blendMode()` effects
- [ ] Maximum ONE shadow per element
- [ ] NO `RadialGradient` or complex gradients in card backgrounds
- [ ] Interactive buttons use `.buttonStyle(.plain)`
- [ ] NO `DispatchQueue.main.async` in computed properties
- [ ] State initialized synchronously in `init()`

---

## Real-World Example: Device Card Fix

**Before (500ms+ render delay):**
```swift
ZStack {
    // Multiple GPU-intensive layers
    RoundedRectangle(cornerRadius: 20)
        .fill(.ultraThinMaterial)
        .overlay {
            RadialGradient(
                colors: [.blue.opacity(0.3), .blue.opacity(0.15), .clear],
                center: .bottomTrailing,
                startRadius: 10,
                endRadius: 100
            )
        }
        .compositingGroup()
        .shadow(color: .black.opacity(0.3), radius: 20)
        .shadow(color: .blue.opacity(0.2), radius: 15)
        .shadow(color: .blue.opacity(0.1), radius: 10)
}

// After (instant render):**
```swift
ZStack {
    RoundedRectangle(cornerRadius: 20)
        .fill(Color.white.opacity(0.12))
        .overlay(
            RoundedRectangle(cornerRadius: 20)
                .stroke(Color.white.opacity(0.2), lineWidth: 1)
        )
        .shadow(color: .black.opacity(0.15), radius: 8, x: 0, y: 4)
}
```

**Result:** Rendering time reduced from 500ms+ to <16ms (instant!)

---

## Remember: Simplicity = Performance

The best UI is the one that renders instantly. Avoid trendy effects that sacrifice user experience.
